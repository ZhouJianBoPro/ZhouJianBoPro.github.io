---
layout: post
title: 线程死锁
date: 2021-10-16
tags: [Java]
---

#### 死锁定义
> 线程死锁是指多个线程因争夺资源而造成的一种互相等待的僵局状态，在没有外力作用的情况下，这些线程都无法继续执行。

#### 死锁的四个必要条件
1. 互斥
    > 资源在任意时刻只能被一个线程占有
2. 持有并等待条件
    > 线程已持有了资源，同时又在等待获取其他线程持有的资源，且等待期间不释放持有的资源。比如线程A占用了打印机，并且等待线程B占用的扫描仪
3. 不可剥夺条件
    > 线程持有的资源不能被强行剥夺，只能由持有的线程主动释放
4. 循环等待条件
    > 存在一个线程资源的循环等待链，如线程A等待线程B持有的资源，线程B等待线程A持有的资源，形成一个循环

#### 死锁预防策略
1. 破坏持有并等待条件
    > 一次性申请占用所有资源，避免持有部分资源再去请求其他资源。比如在银行转账过程中，同时申请转出账户与转入账户
2. 破坏不可剥夺条件
    > 设置强制释放资源，比如使用Lock#tryLock代替synchronized
3. 破坏循环等待条件
    > 所有线程按照相同顺序获取资源，比如有A,B两个资源，所有线程都按照A -> B的顺序申请资源


#### 线程死锁代码示例
```java
public class DeadLock {

   private static String resource1 = "A";
   private static String resource2 = "B";

   public static void main(String [] args) {

      Thread t1 = new Thread(() -> {
         String threadName = Thread.currentThread().getName();
         synchronized (resource1) {
            System.out.println(threadName + "线程获取到" + resource1);
            try {
               // 使得t2线程线获取到object2
               Thread.sleep(100);
            } catch (InterruptedException e) {
               throw new RuntimeException(e);
            }
            synchronized (resource2) {
               System.out.println(threadName + "线程获取到" + resource2);
            }
         }
      }, "t1");

      Thread t2 = new Thread(() -> {

         String threadName = Thread.currentThread().getName();
         synchronized (resource2) {
            System.out.println(threadName + "线程获取到" + resource2);
            try {
               // 使得t1线程线获取到object1
               Thread.sleep(100);
            } catch (InterruptedException e) {
               throw new RuntimeException(e);
            }
            synchronized (resource1) {
               System.out.println(threadName + "线程获取到" + resource1);
            }
         }
      }, "t2");

      t1.start();
      t2.start();
   }
}
```