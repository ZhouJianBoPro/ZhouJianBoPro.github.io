---
layout: post
title: 深入了解多线程
date: 2018-03-16
categories: thread
tags: [thread]
description: 深入了解多线程
---

**线程的实现**<br/>

1.继承Thread类
```java
public class Test {

    public static void main(String[] args) {
        //main方法其实就是个主线程
        System.out.println("主线程名 = " + Thread.currentThread().getName() + ",主线程ID = " + Thread.currentThread().getId());
        //创建并启动Thread1线程
        MyThread thread1 = new MyThread("t1");
        //启动线程后会自动调用run()
        thread1.start();

        MyThread thread2 = new MyThread("t2");
        //并未启动thread2线程，仅仅是调用MyThread中的run()
        thread2.run();
    }
}

/**
 * 继承Thread类，其实Thread类也是实现过了Runnale接口
 */
class MyThread extends Thread {

    private String name;

    public MyThread(String name) {
        this.name = name;
    }

    /**
     * 继承Thread类必须实现run()方法
     * run()不是启动新线程的方法，里面是线程执行的任务,和调用普通方法一致
     * 启动新线程的方法是Thread中的start()方法;
     */
    @Override
    public void run() {
        System.out.println("线程名称 = " + name + ",子线程ID = " + Thread.currentThread().getId());
    }
}
```
```html
执行结果
  主线程名 = main,主线程ID = 1
  线程名称 = t2,子线程ID = 1
  线程名称 = t1,子线程ID = 10, <从执行结果可以看出：新线程的创建不会阻塞主线程的后续执行>
```
2.实现Runnable接口
```java
package com.test.thread;

public class Test {

    public static void main(String[] args) {
        //创建并启动Thread1线程
        MyThread2 thread1 = new MyThread2();
        //启动线程后会自动调用run()
        Thread thread = new Thread(thread1);
        thread.start();
    }
}

/**
 * 实现Runnable接口，好处：可以避免单继承
 */
class MyThread2 implements Runnable {

    @Override
    public void run() {
        System.out.println("子线程ID = " + Thread.currentThread().getId());
    }
}
```

**线程的五种状态**
- 创建(new)：准备好了一个多线程的对象。
- 就绪(runnable)：调用了start()方法，等待cpu进行调度。
- 运行(running)：执行了run()方法。
- 阻塞(blocked)：暂时停止执行,可能将资源给其他线程使用。
- 终止(dead)：线程销毁

**sleep和wait之间的区别**
- sleep是Thread类中定义的方法，wait是Object中定义的方法.
- Thread.sleep和Object.wait都会暂停当前线程，区别是wait必须其他线程执行notify/notifyAll才能获得cpu执行资源。

**上下文切换**
- 切换线程要保存当前线程状态，以便下次恢复能够切换到之前的状态
- 当前线程还没有执行完，切换线程时需要保存线程的状态，
以便下次恢复时能够切换到之前的状态；比如一个线程A在读取文件的内容，
文件读取到一半时，此时需要去执行B线程，当再次切换至A线程，
我们又不希望A又从文件的头部开始读取，因此需要记录线程A的执行状态，
线程上下文切换时需要记录程序计数器，cpu寄存器等数据。

**线程常用的方法**
- start()：启动线程，虚拟机调用该线程的run();
- run()：线程需要执行的任务;
- join()：防止主线程先于子线程执行完
- yield()：暂停当前执行的线程，并执行其他线程，不会释放锁
- sleep()：在指定的毫秒内让当前线程休眠，不会执行其他线程，不会释放锁，如果当前对象被锁定，其他线程还是不能访问该对象。
- interrupt()：中断线程;
- setPriority()：更改线程的优先级;
- setDaemon()：为该线程设为守护线程;

**sleep()详解(阻塞)**
1. 使当前线程暂停若干毫秒，将cpu资源给其他线程;
2. 当暂停时间结束后，可能并不会立即执行，因为此时cpu可能在执行其他线程，所以说调用sleep方法相当于让该线程处于阻塞状态，经过阻塞时间后进入就绪状态。
3. sleep方法不能释放锁，当前对象被锁定时，其他线程不能共享该对象。

**yield()详解(就绪)**
- 与sleep相似点，将cpu资源给到其他线程，同时也不会释放锁；
- 与sleep区别：1.不能控制控制该线程睡眠的具体时间；
2.使该线程处于就绪状态，只需等待cpu执行时间即可;
3.yield只能让拥有优先级较高的线程执行；
4.yield移植型较差，一般不建议使用yield控制高并发；

**Object中的wait方法**<br/>

与sleep之间的区别
1. 会释放锁，同步代码块及方法锁定的对象可以被其他线程访问；
2. 要等待其他线程调用notify/notifyAll唤醒休眠的线程。


**join()详解**
>防止主线程先于子线程执行完；如果子线程中存在大量逻辑运算，主线程往往会先于子线程执行完；比如子线程处理一个耗时数据，而主线程需要得到这个数据，此时就应该使用join()；

**守护线程与用户线程之间的区别**
> 守护线程随着主线程的消亡而消亡，用户线程不受主线程的影响；在JVM中，垃圾收集器就是一个守护线程。

**守护线程定义规则**
>设置守护线程必须在start()之前，否则会抛出异常。

**同步与死锁**<br/>

1.同步实现
- 同步代码块 synchronized(同步对象) {}
- 同步方法:synchronized void 方法名称(){}

**同步代码块与同步方法之间的区别**
- 同步方法锁住的是操作该方法的对象，范围更大。
- 同步代码块锁住的是某个设定的对象，范围较小。
- 一般在处理多并发问题时，尽量使用同步代码块，范围越小性能越高。

**死锁**
- 死锁(当一个线程同时持有多个锁时，可能造成死锁)
- 规避方法:用同步代码块代替同步方法；尽量不要让线程在同一时刻拥有多个锁
- 创建大锁代替小锁，而不是作用于单个对象范围内的单对象级别锁

**面试题**<br/>

1.线程和进程有什么区别？<br/>
> 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

2.如何在Java中实现线程？<br/>
> 创建线程有两种方式：
一、继承 Thread 类，扩展线程。
二、实现 Runnable 接口。

3.启动一个线程是调用run()还是start()方法？<br/>
> 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。

4.Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?<br/>
> sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

5.线程的sleep()方法和yield()方法有什么区别？<br/>
- sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
- 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
- sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

6.请说出与线程同步以及线程调度相关的方法<br/>
- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；