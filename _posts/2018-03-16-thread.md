---
layout: post
title: thread
date: 2018-03-16
categories: thread
tags: [thread]
description: 深入了解多线程
---

**线程的实现**<br/>

1.继承Thread类
```java
public class Test {

    public static void main(String[] args) {
        //main方法其实就是个主线程
        System.out.println("主线程名 = " + Thread.currentThread().getName() + ",主线程ID = " + Thread.currentThread().getId());
        //创建并启动Thread1线程
        MyThread thread1 = new MyThread("t1");
        //启动线程后会自动调用run()
        thread1.start();

        MyThread thread2 = new MyThread("t2");
        //并未启动thread2线程，仅仅是调用MyThread中的run()
        thread2.run();
    }
}

/**
 * 继承Thread类，其实Thread类也是实现过了Runnale接口
 */
class MyThread extends Thread {

    private String name;

    public MyThread(String name) {
        this.name = name;
    }

    /**
     * 继承Thread类必须实现run()方法
     * run()不是启动新线程的方法，里面是线程执行的任务,和调用普通方法一致
     * 启动新线程的方法是Thread中的start()方法;
     */
    @Override
    public void run() {
        System.out.println("线程名称 = " + name + ",子线程ID = " + Thread.currentThread().getId());
    }
}
```
```html
执行结果
  主线程名 = main,主线程ID = 1
  线程名称 = t2,子线程ID = 1
  线程名称 = t1,子线程ID = 10, <从执行结果可以看出：新线程的创建不会阻塞主线程的后续执行>
```
2.实现Runnable接口
```java
package com.test.thread;

public class Test {

    public static void main(String[] args) {
        //创建并启动Thread1线程
        MyThread2 thread1 = new MyThread2();
        //启动线程后会自动调用run()
        Thread thread = new Thread(thread1);
        thread.start();
    }
}

/**
 * 实现Runnable接口，好处：可以避免单继承
 */
class MyThread2 implements Runnable {

    @Override
    public void run() {
        System.out.println("子线程ID = " + Thread.currentThread().getId());
    }
}
```

3.实现Callable接口并通过FutrueTask包装（有返回值）

```java
public class DemoTest implements Callable<String> {


    @Override
    public String call() throws Exception {
        return "111";
    }

    public static void main(String[] args) throws Exception {

        DemoTest demoTest = new DemoTest();
        FutureTask<String> f = new FutureTask<String>(demoTest);
        Thread t = new Thread(f);
        t.start();
        System.out.println(f.get());
    }
}
```

4.通过Lambda表达式实现

```java
new Thread(() -> System.out.println("111")).start();
```

**线程的五种状态**
- 创建(new)：准备好了一个多线程的对象。
- 就绪(runnable)：调用了start()方法，等待cpu进行调度。
- 运行(running)：执行了run()方法。
- 阻塞(blocked)：暂时停止执行,可能将资源给其他线程使用。
- 终止(dead)：线程销毁

**sleep和wait之间的区别**
- sleep是Thread类中定义的方法，wait是Object中定义的方法.
- Thread.sleep和Object.wait都会暂停当前线程，区别是wait必须其他线程执行notify/notifyAll才能获得cpu执行资源。

**线程常用的方法**
- start()：启动线程，虚拟机调用该线程的run();
- run()：线程需要执行的任务;
- join()：使得一个线程在另一个线程（调用join方法线程）结束后再执行，当前运行线程阻塞
- yield()：暂停当前执行的线程，并执行其他线程（优先级更改的线程先执行），不会释放锁，同步后其他线程不能访问
- sleep()：在指定的毫秒内让当前线程休眠，让其他线程有机会继续执行（公平竞争），不会释放锁，如果当前对象被锁定，其他线程还是不能访问该对象。
- interrupt()：中断线程;
- setPriority()：更改线程的优先级;
- setDaemon()：为该线程设为守护线程;

**sleep()详解(阻塞)**
1. 使当前线程暂停若干毫秒，将cpu资源给其他线程;
2. 当暂停时间结束后，可能并不会立即执行，因为此时cpu可能在执行其他线程，所以说调用sleep方法相当于让该线程处于阻塞状态，经过阻塞时间后进入就绪状态。
3. sleep方法不能释放锁，当前对象被锁定时，其他线程不能共享该对象。

**yield()详解(就绪)**
- 与sleep相似点，将cpu资源给到其他线程，同时也不会释放锁；
- 与sleep区别：1.不能控制控制该线程睡眠的具体时间；
2.使该线程处于就绪状态，只需等待cpu执行时间即可;
3.yield只能让拥有优先级较高的线程执行；
4.yield移植型较差，一般不建议使用yield控制高并发；

**Object中的wait方法**<br/>

与sleep之间的区别
1. 会释放锁，同步代码块及方法锁定的对象可以被其他线程访问；
2. 要等待其他线程调用notify/notifyAll唤醒休眠的线程。


**join()详解**
>防止主线程先于子线程执行完；如果子线程中存在大量逻辑运算，主线程往往会先于子线程执行完；比如子线程处理一个耗时数据，而主线程需要得到这个数据，此时就应该使用join()；
使得一个线程在另一个线程（调用join方法线程）结束后再执行，当前运行线程阻塞

**守护线程与用户线程之间的区别**
> 守护线程随着主线程的消亡而消亡，用户线程不受主线程的影响；在JVM中，垃圾收集器就是一个守护线程。

**守护线程定义规则**
>设置守护线程必须在start()之前，否则会抛出异常。

**同步与死锁**<br/>

1.同步实现
- 同步代码块 synchronized(同步对象) {}
- 同步方法:synchronized void 方法名称(){}

**同步代码块与同步方法之间的区别**
- 同步方法锁住的是操作该方法的对象，范围更大。
- 同步代码块锁住的是某个设定的对象，范围较小。
- 一般在处理多并发问题时，尽量使用同步代码块，范围越小性能越高。

**死锁**
- 死锁(两个线程无线等待对方持有的锁，同步中嵌套了其他同步)
- 规避方法:尽量不要在同步中嵌套其他同步
- 在等待的时间加上期限，sychronized不支持，但是Lock中的tryLock可以设置在一定时间内没有获取到锁，放弃继续获取对方的锁

```java
//创建锁对象
public class Lock {
    //这里用private封装，为了不让外面随便造锁，限制只能有A，B锁个一把，这样容易出现死锁
    //即A同学和B同学想相互串门，可是没人只有一把自己房间的钥匙，而且各自都不愿意先给，于是死锁
    private Lock() {};
    public static final Object lockA =new Object();
    public static final Object lockB = new Object();
    //这里使用static 为了让外界可以通过类名调用成员变量lockA和lockB
    //因为外面无法创建Lock对象，为了让外面在不创对象的情况下调用，加了static，通过类名加变量名访问
}


//线程任务
public class ThreadTask implements Runnable {
    int x = new Random().nextInt(1);//用随机数随机获取0、1，来模拟CPU随机分配执行权的行为
    @Override
    public void run() {
        while(true) {
            if(x%2==0) {
                synchronized(Lock.lockA) {
                    System.out.println("A同学...开A门");
                    synchronized(Lock.lockB) {
                        System.out.println("A同学...开B门");
                    }
                }
            }else {
                synchronized(Lock.lockB) {
                    System.out.println("B同学...开B门");
                    synchronized(Lock.lockA) {
                        System.out.println("B同学...开A门");
                    }
                }
            }
            x++;
        }
      }
    }

```
**面试题**<br/>

1.线程和进程有什么区别？<br/>
> 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

2.如何在Java中实现线程？<br/>
> 创建线程有两种方式：
一、继承 Thread 类，扩展线程。
二、实现 Runnable 接口。

3.启动一个线程是调用run()还是start()方法？<br/>
> 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。

4.Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?<br/>
> sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

5.线程的sleep()方法和yield()方法有什么区别？<br/>
- sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
- 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
- sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。

6.请说出与线程同步以及线程调度相关的方法<br/>
- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；