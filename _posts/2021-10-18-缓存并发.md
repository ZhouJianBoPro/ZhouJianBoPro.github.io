---
layout: post
title: 缓存并发
date: 2021-10-18
tags: [Cache]
---

#### 缓存穿透
1. 原因：并发查询一个数据库和缓存中一定不存在的数据
2. 现象：如果传入的key在缓存和数据库中都不存在value，每次查询都会对缓存和数据库进行操作，会对数据库造成压力
3. 解决方案：采用缓存空值的方式，即使数据库中没有查询到数据，我们也将该key放入缓存中，value设置为空，同时给该key设置ttl

#### 缓存雪崩
1. 现象：在某一时间段内缓存集体失效过期，会给数据库造成周期性的压力
2. 原因：ttl到期/缓存服务器宕机
3. 场景：在活动推广期间，将商品从数据库中提前加载到缓存中，超过活动时间候缓存集体失效
4. 解决方案：
    - 针对缓存集体失效根据场景设置不同的ttl，比如可以增加一个随机因子避免集中过期
    - redis高可用部署，避免缓存服务器宕机查询不到数据。可采用集群部署（分片 + 至少3主3从）

#### 缓存击穿
1. 现象：对一个key进行高并发访问，当这个key失效时，数据库并发访问压力瞬间增大
2. 解决方案： 
   - 合理设置缓存ttl
   - 只让一个请求去加载数据到缓存，其他请求等待
    ```java
    public void set(String key, String value, int expireTime) {
        Object result = cache.get(key);
        if (result == null) {
            synchronized (lock) {
                if ((result = cache.get(key)) == null) {
                    result = db.query(key);
                    cache.put(key, value, expireTime);
                }
            }
        }
    }
    ```