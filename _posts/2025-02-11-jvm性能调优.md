---
layout: post
title: jvm性能调优
date: 2025-02-11
tags: [jvm]
---

#### 栈内存
- 用于存储方法调用时的信息，如方法参数、局部变量、返回值、异常信息等，每个线程私有
- 栈内存生命周期：线程启动时，为其分配栈内存。线程结束时，栈内存被释放
- 参数设置：-Xss1M，默认每个线程的栈内存为1M，建议不要超过该值
- 栈内存溢出：同一时刻线程过多；递归调用过深

#### 元空间与永久代区别
- 元空间与永久代都是存储元数据（如类定义、方法、常量池信息等）的内存区域
- 存储位置：永久代存储在堆内存中，元空间存储在本地内存中
- 内存管理：永久代需要手动设置，元空间是动态扩展的，默认无上限
- 垃圾回收：永久代相比于元空间效率更低，容易触发Full GC
- 参数设置：永久代（-XX:PermSize=128M，-XX:MaxPermSize=512），元空间（-XX:metaspaceSize=256M， -XX:MaxMetaspaceSize=256M，建议设置为256M-512M区间范围内）
- 适用版本：元空间适用于java8及以后版本，永久代适用于java7及以前版本

#### 堆内存
- 堆内存用于存储对象实例和数组，所有线程共享
- 堆内存区域划分：年轻代（eden、survivor）和老年代（old）
- 年轻代：eden用于存放新创建的对象，在eden区经过一次垃圾回收后还存活的对象会被移动到survivor区，年轻代的垃圾回收被称为Minor GC
- 老年代：存放长期存活的对象，对象在年轻代经过多次垃圾回收（-XX:MaxTenuringThreshold=15）还存活，会被提升至老年代区。老年代的垃圾回收被称为Full GC
- 堆内存参数设置：-Xms1024M（堆内存初始值，建议与最大值保持一致，避免内存动态调整带来的开销）；-Xmx1024M（堆内存最大值），建议为物理内存的50%-70%
- 年轻代参数设置（两种方式）：-Xmn512M（直接指定年轻代大小），-XX:NewRatio=2（老年代/年轻代的比例，年轻代1/3），建议年轻代占堆内存的40%-60%
- eden与survivor在年轻代占比：-XX:SurvivorRatio=8，默认eden占年轻代80%，survivor中的to和from两个分区分别占10%
- 老年代内存 = 堆内存大小 - 年轻代大小

#### 垃圾回收触发条件
- 当eden区内存不足时，会触发Minor GC；当年轻代survivor区中的to分区没有足够的内存空间来容纳从eden和from区复制过来的对象时，这些对象会直接晋升到老年区
- 当年老代区内存不足时（不足以容纳年轻代晋升的对象），会触发Full GC
- Metaspace元空间内存不足时，会出发Full GC
- 显示调用System.gc()时，会出发Full GC

#### 频繁GC的后果
- 停顿时间或频率增加：Minor GC会导致频繁停顿，影响应用程序的响应时间。Full GC 会导致长时间停顿，严重影响程序的可用性
- CPU使用率上升：GC过程中会占用大量CPU资源
- 频繁GC可能存在内存泄漏的风险

#### 常用垃圾回收器
- 串行垃圾回收器Serial（-XX:+UseSerialGC）：适用于单核CPU
- 并行垃圾回收器Parallel（-XX:+UseParallelOldGC）：适用于多核CPU，关注系统吞吐量，JDK8默认；在年轻代使用（标记-复制）算法，在老年代使用（标记-清除-整理）算法
- G1（-XX:+UseG1GC）：适用于多核CPU，关注用户停顿时间，JDK9默认

#### 如何避免频繁GC
- 合理设置堆内存及其年轻代大小，适当提升堆内存大小
- 调整对象晋升老年代的年龄（-XX:MaxTenuringThreshold=15），让对象在年轻代内存多存活，减少Full GC频率
- 禁止代码中显示调用System.gc()
- 减少对象的创建，尽量做到对象进行复用，或者使用对象池来管理对象的创建和销毁
- 尽量避免创建大对象，当设置了年轻代对象阈值时（-XX:PretenureSizeThreshold=1000000）时，大对象会直接进入到老年代内存区域中

#### OOM产生原因
- 方法递归调用层数太深，可能会导致栈内存溢出
- 程序运行时产生大量动态代理类时可能会导致元空间溢出
- 程序运行产生大量对象，或者加载大对象时可能会导致堆内存溢出
- IO连接、ThreadLocal等使用完未手动关闭，可能导致堆内存溢出

#### GC频率合理范围
- Full GC 最差情况下控制在一小时一次，尽量控制每天一次，而且每次Full GC完成时间在1s内，负责系统停顿时间太长不可用
- Minor GC 每分钟几次是合理的，因为大部分对象生命周期都较短，持续时间100ms以内

#### 如何排查OOM问题
- 在jvm启动时配置-XX:+HeapDumpOnOutOfMemoryError，发生OOM自动生成堆转储文件，通过JProfiler等工具分析文件找出问题
- 通过jstat命令查看jvm内存使用情况，通过查询eden,survivor,old区内存使用情况，及Minor GC和Full GC发生频率

#### jvm其他参数
- -XX:+PrintGCDetails：打印GC信息，包括GC类型、开始时间、持续时间、回收对象数量、回收大小等
- -XX:+PrintGCTimeStamps：打印GC时间戳，方便分析GC日志
- -XX:+HeapDumpOnOutOfMemoryError ：当发生OOM时，自动生成堆转储文件，便于分析问题
- -XX:HeapDumpPath=/Users/logs/dump.hprof ：指定堆转储文件路径
- -Dloader.path=/opt/libs ：设置类加载路径，方便加载外部jar包

#### 其他优化方案
- 增加机器，分散节点压力
- 使用缓存或消息队列等中间件
- 合理设置线程池参数

#### 调整线程池参数
- CPU密集型核心线程数：N + 1，N为CPU核数，数量与CPU核数相近是为了不浪费CPU资源，并尽可能减少上下文切换，+1是为了在线程阻塞后还能不浪费CPU算力
- IO密集型核心线程数：2N，IO密集型任务线程执行时间较长，IO操作会阻塞线程，此时可以让线程去处理其他任务，从而充分利用CPU资源
- 最大线程数：建议设置为核心线程数的2-4倍


