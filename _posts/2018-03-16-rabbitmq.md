---
layout: post
title: 深入了解RabbitMQ
date: 2018-03-16
categories: message queue
tags: [mq]
description: 深入了解RabbitMQ。
---

**中文文档**
> https://www.kancloud.cn/yunxifd/rabbitmq/94125

## rabbitmq详细介绍

**应用场景**
> 分布式环境中实现不同模块或子系统的相互通信。

**Rabbit Server**
> 维护一条从Producer到Consumer的路线,保证数据按指定的方式传输。

**Clien A&B**
> 称之为Producer,也就是数据的发送方，一个message由两部分构成：payload(传输的数据)和lable(标签)，label是exchange的名字，他描述了payload,而且rabbitmq通过lable来决定把这个message发送到哪个Consumer。

**Client 1&2&3**
>也叫Consumer，数据的接收方，把queue看做是一个有名字的邮箱，当message到达这个邮箱时，rabbitmq把message转发到所有订阅过它的订阅者(Consumer);在这个message中，只有payload,lable被删除了，对于Consumer来说，它是不需要知道是谁发送这个信息的。

**其他概念**
- Exchanges:Producer发布信息的地方;
- Queues:消息最终被Consumer接收的地方;
- Bindings:消息如何从交换路由到特定队列的方式;
- Connection:是一个TCP链接，Producer和Consumer通过TCP连接到rabbitmq server上;
- Channels:虚拟链接，数据流动都是在Channel中，是建立在TCP连接中的

**RabbitMQ中使用Channel的优势**
- 对于OS来说，建立和关闭TCP连接都是有代价的，频繁的进行建立和关闭对系统性能有消耗；
- 在TCP连接中建立Channel是没有上述代价的;

**使用ack确认message正确传递**
- 默认情况下，如果message被某个或多个Consumer正确接收到，该message就会被从queue中移除掉。
- 如果一个queue没有被Consumer订阅，且该queue中有数据到达，那么该数据将会被缓存，直到有Consumer订阅时，将message传递给Consumer。
- 判定message被正确接收到:通过ack,每个message都要被ack（确认）,如果数据没有被ack，RabbitMQ将此message发送给下一个Consumer。

**Creating a queue**
> Producer和Consumer都可以通过queue.declare创建queue

**谁负责创建这个queue,Producer or Consumer**
> 如果queue不存在，Consumer接收不到任何的messgae,Producer publish的message都会被丢失,所以说Producer和Consumer都应该创建queue;

**Exchanges**
- Producer public的message进入了Exchanges中，接着通过routing keys 将message放入到指定的queue中，queue也是通过routing key作绑定的；
- Direct exchange:如果routing key匹配，那么message会被传递到相应的queue中，其实在queue创建时，自动以queue的名字作为routing key来绑定exchange;
- Fanout exchange:向响应的queue广播；
- Topic exchange:对key进行模式匹配；

**注意事项**
- 队列只会在它不存在的时候创建，重复声明不会重复创建;
- 信息的内容是字节数组，意味着可以传输任何数据;

**rabbitMQ的五种形式队列**
1. [点对点队列](#point)
2. [工作队列模式(work queue)](#work)
3. [发布/订阅模式(publish/subscribe)](#public)

工作流程：<br/>
连接server
```java
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
Connection connection = factory.newConnection();
Channel channel = connection.createChannel();
```
Connection抽象了socket连接，接下来我们创建了channel,api操作都是通过channel来完成的<br/>

<span id="point"><font color="#dd0000">点对点队列</font><br /></span>
```java
channel.queueDeclare(QUEUE_NAME, false, false, false, null);
String message = "Hello World!";
channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
System.out.println(" [x] Sent '" + message + "'");
```
通过channel声明一个queue，该queue是幂等的，也就是说该queue不存在的时候才会创建queue，实际传递的
消息内容为字节数组，没有声明exchange，使用默认的exchange，exchange_name = "";

```java
channel.close();
connection.close();
```
先关闭channle，然后再关闭connection<br/>

完整的produce代码：
```java
public class ProduceDemo {
 
    private static final String QUEUE_NAME = "hello";
 
    public static void main(String[] args) {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("localhost");
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();
 
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        String message = "Hello World!";
        channel.basicPublish("", QUEUE_NAME, null, message.getBytes());
        System.out.println(" [x] Sent '" + message + "'");
 
        channel.close();
        connection.close();
    }
 
}
```
Consumer接收消息：
```java
public class ConsumerDemo {
 
    private final static String QUEUE_NAME = "hello";
 
    public static void main(String[] argv) throws Exception {
      ConnectionFactory factory = new ConnectionFactory();
      factory.setHost("localhost");
      Connection connection = factory.newConnection();
      Channel channel = connection.createChannel();
 
      //该queue_name要和produce中声明的queue_name相等，否则消费不了
      channel.queueDeclare(QUEUE_NAME, false, false, false, null);
      System.out.println(" [*] Waiting for messages. To exit press CTRL+C");
 
      Consumer consumer = new DefaultConsumer(channel) {
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)
            throws IOException {
          String message = new String(body, "UTF-8");
          System.out.println(" [x] Received '" + message + "'");
        }
      };
      //autAck = true
      channel.basicConsume(QUEUE_NAME, true, consumer);
    }
}
```
在接收消息时也要声明一个queue_name，且该queue_name要和produce中声明的queue_name相同

<span id="work"><font color="#dd0000">工作队列模式</font><br /></span><br/>
1.将积压的任务分配给多个work queue,通过若干个work queue共同完成这些工作，实现原理同点对点
队列相同，其实就是分配多个work来共同处理这些任务<br/>

2.假设队列中有五条消息待处理，我们同时启动两个Consumer来消费队列中的消息
```html
首先是第一个Consumer打印出的消息
[*] Waiting for messages. To exit press CTRL+C
[x] Received 'First message.'
[x] Received 'Third message...'
[x] Received 'Fifth message.....'

第二个Consumer打印出来的消息
[*] Waiting for messages. To exit press CTRL+C
[x] Received 'Second message..'
[x] Received 'Fourth message....'
```
可以看出，rabbitMQ会顺序的将任务发送到下一个Consumer,平均来说每个Consumer执行的任务是相等的


**消息接收(message acknowledgment)**
- 现状是rabbitMQ将消息传递到一个Consumer,这条消息在队列中马上会被删除；如果一个任务执行
耗时较长，Consumer只处理完该任务一部分逻辑，这样就会使得未处理完部分任务丢失。
- 一般情况下，我们不希望在消息没处理完之前就从队列中清除，如果某个work挂了，该任务由另外一个
work处理；rabbitMQ支持ack，当Consumer确认某个任务处理完，它会向rabbitMQ发送一个ack确认清除队列中的任务
- 如果Consumer挂了或连接被关闭，而没有发送ack，rabbitMQ会知道该消息没有处理完，会进行re-queue操作，
使用这种操作可以保证消息不会丢失

**消息持久化**<br/>
1.消息接收可以保证work挂掉的情况下，消息可以恢复到队列中，但是如果rabbitMQ server异常崩溃而
停止服务，将会失去所有的queue和消息，要保证这种情况下消息不丢失要做两件事情：需要同时标志queue和
message都是持久化的

1)首先确保在rabbitMQ停止服务时queue不会丢失，produce和consumer中queue声明为持久
```java
//设置durable属性为true，即使
boolean durable = true;
channel.queueDeclare("task_queue", durable, false, false, null);
```
2)接下来我们做消息持久化处理，通过设置MessageProperties(实现了BasicProperties)中的PERSISTENT_TEXT_PLAIN属性
```java
channel.basicPublish("", "task_queue", MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes("utf-8"));
```

**公平分发**
- 某种场景下，有两个work，如果奇数任务处理起来比较耗时，rabbitMQ继续将任务顺序分配时会造成
一个work busy，另外一个work空闲
- 处理这种情况在（Consumer中）增加channel.basicQos(1);设置，rabbitMQ一次只给Consumer一条消息，知道有ack返回
再向该Consumer发送另一条消息

```java
int prefetchCount = 1;
channel.basicQos(prefetchCount);
```


<span id="public"><font color="#dd0000">发布/订阅模式</font><br /></span><br/>
1.定义：每条消息都会传递给所有的consumer，本质上，将消息广播给所有接收者<br/>

2.Exchange：一边接收producer发送的消息，一边将消息推送至queue中；之前的点对点及work queue模式都是通过queue来发送和接收消息的，这两种模式的几个概念：
- Producer：应用负责发送消息
- queue：消息存储的缓存
- Consumer：应用负责接收消息

3.rabbitMQ完整消息模型的核心思想是：producer永远不会直接把消息发送至queue中，在rabbitMQ中，producer
将消息发送至exchange中，由exchange将消息推送至queue中<br/>

4.exchange在收到消息后将消息发送至queue中的几种机制（exchange的类型）：<br/>

1)direct：当exchangeDeclare 类型指定为direct时，publish message需要指定routing key，exchange会将消息发送至指定的queue（绑定过routing key）中
```java
//声明exchange，类型为direct
channel.exchangeDeclare(QueueConstants.BACKTEST_REQUEST_EXCHANGE, "direct", true);
//声明queue，队列设置为持久化
channel.queueDeclare(QueueConstants.BACKTEST_REQUEST_QUEUE, true, false, true, null);
//将exchange和queue绑定
channel.queueBind(QueueConstants.BACKTEST_REQUEST_QUEUE, QueueConstants.BACKTEST_REQUEST_EXCHANGE, ROUTING_KEY);

//public message时指定routing key，且要和queue绑定时的routing key相同
channel.basicPublish(QueueConstants.BACKTEST_REQUEST_EXCHANGE, ROUTING_KEY, null, json.getBytes("UTF-8"));
```
2)fanout：将message广播至所有队列中，不用设置routing key，publish时一般需要设置ttl，防止mq堵塞
```java
Channel channel = connection.createChannel();
channel.queueDeclare(QueueConstants.BACKTEST_REQUEST_QUEUE, true, false, true, null);
channel.exchangeDeclare(QueueConstants.LOGIN_EXCHANGE, "fanout", true);
channel.close();

channel = connection.createChannel();
//设置ttl，因为是广播模式，一个消息可供多个Consumer接收，不会清除，因此设置ttl防止积存的数据过多导致mq堵塞
AMQP.BasicProperties.Builder properties = new AMQP.BasicProperties.Builder();
properties.expiration("1800000");//ttl 30min
// routingKey value is ignored for fanout exchanges
channel.basicPublish(QueueConstants.LOGIN_EXCHANGE, "", properties.build(), json.getBytes("UTF-8"));
```
3)topic：exchange会将消息转发到所有通过模糊routing key绑定的queue中，原理同direct类似（通过确定的routing key绑定），
routing key不能是一个确定的值，必须是使用点分隔开的单词列表
- \#：该通配符表示若干个关键字
- \*：表示一个关键字
- 如routing key = "#.log.#"表示该队列关心所有涉及log的消息；
- 如"log.*"能与"log.warn"匹配，无法与"log.warn.timeout"匹配；但是"log.#"能与上述两者匹配

5.广播模式Consumer接收消息：重新声明queue及绑定producer中的exchange(在Producer中没有声明queue)
```java
connection = messageService.connect();
Channel channel = connection.createChannel();
//自己重新声明queue
channel.queueDeclare(QueueConstants.CREATED_CONDITION_QUEUE, true, false, false, null);
//为queue绑定Producer中的exchange
channel.queueBind(QueueConstants.CREATED_CONDITION_QUEUE, "condition_order_first_create_exchange", "");

DefaultConsumer consumer = new DefaultConsumer(channel) {

    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
        String message = new String(body, "UTF-8");
        createMessage(message);

    }
};
channel.basicConsume(QueueConstants.CREATED_CONDITION_QUEUE, true, consumer);
```
