---
layout: post
title: jdk动态代理
date: 2022-10-23
tags: [designMode]
---

#### 什么是动态代理
> 在程序运行时，通过反射机制动态为目标类创建代理对象，无需手动编写代理类

#### 静态代理与动态代理的区别
> 静态代理代理和被代理的对象在代理之前是确定的，他们都实现相同的接口或继承相同的抽象类；而动态代理是在程序运行的时候自动为目标类创建代理类

#### JDK动态代理
> 当被代理的目标类实现了接口，默认使用JDK动态代理为目标类动态创建代理对象。JDK动态代理主要通过Proxy类和InvocationHandler接口实现，
Proxy根据传递过来的参数动态创建代理类，InvocationHandler用于对目标方法的增强及调用目标类的方法

```java
public class JDKProxyTest {

    // 测试
    public static void main(String[] args) {
        ISubject proxy = ProxyFactory.createLoggingProxy(new RealSubject());
        proxy.call();
    }

    // 接口
    public interface ISubject {
        void call();
    }

    // 真实类
    public static class RealSubject implements ISubject {
        @Override
        public void call() {
            System.out.println("RealSubject.call()");
        }
    }

    // 动态代理调用处理器（日志）
    public static class LoggingProxyInvocationHandler implements InvocationHandler {

        // 目标对象
        private final Object target;

        public LoggingProxyInvocationHandler(Object target) {
            this.target = target;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            before();
            Object invoke = method.invoke(target, args);
            after();
            return invoke;
        }

        private void before() {
            System.out.println("LoggingProxyInvocationHandler.before()");
        }

        private void after() {
            System.out.println("LoggingProxyInvocationHandler.after()");
        }
    }

    // 代理工厂，可以创建不同类型的代理对象
    public static  class ProxyFactory {

        // 通用创建代理对象
        public static <T> T createProxy(T target, InvocationHandler handler) {
            return (T) Proxy.newProxyInstance(
                    target.getClass().getClassLoader(),
                    target.getClass().getInterfaces(),
                    handler
            );
        }

        // 创建日志代理对象
        public static <T> T createLoggingProxy(T target) {
            return createProxy(target, new LoggingProxyInvocationHandler(target));
        }
    }
}
```

#### jdk动态代理问题
被代理对象必须要实现接口。因为动态生成的代理类继承了Proxy(单继承)，且实现了被代理对象实现的接口
```java
//代理类继承了Proxy，实现Subject接口
public final class $Proxy0 extends Proxy implements Subject {
    
    //初始化ProxyInvocationHandler
    public $Proxy0(InvocationHandler var1) {
        super(var1);
    }

    //实际上调用的是ProxyInvocationHandler#invoke
    public final void call() {
        super.h.invoke(this, m3, (Object[])null);
    }
}
```

#### jdk动态代理实现场景
> mybatis为每个Mapper接口动态生成实现类和方法，并且这个代理创建的方法关联到mapper.xml文件中的sql与参数注入

