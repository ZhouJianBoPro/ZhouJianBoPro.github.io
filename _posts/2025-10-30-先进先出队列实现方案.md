---
layout: post
title: 先进先出队列实现方案
date: 2025-10-30
tags: [concurrency]
---

#### 通过ArrayList集合实现
> 效率不如LinkedList，ArrayList在插入和删除元素时需要便利整个集合，时间复杂度O(n)
```java
public class MyQueue {

    private ArrayList<Integer> data;

    private int capacity;

    public MyQueue(Integer capacity) {
        data = new ArrayList<>(capacity);
        this.capacity = capacity;
    }

    public void enqueue(Integer value) {

        if(data.size() >= capacity) {
            throw new IllegalStateException("Queue is full");
        }

        data.add(value);
    }

    public Integer dequeue() {
        if(data.isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }

        return data.remove(0);
    }

    public static void main(String[] args) {
        MyQueue queue = new MyQueue(4);
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);

        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());

        queue.enqueue(4);
        queue.enqueue(5);
        queue.enqueue(6);
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
    }
}
```

#### 通过LinkedList实现
```java
public class MyQueue {

    private LinkedList<Integer> data;

    private int capacity;

    public MyQueue(Integer capacity) {
        data = new LinkedList<>();
        this.capacity = capacity;
    }

    public void enqueue(Integer value) {

        if(data.size() >= capacity) {
            throw new IllegalStateException("Queue is full");
        }

        data.addLast(value);
    }

    public Integer dequeue() {
        if(data.isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }

        return data.removeFirst();
    }

    public static void main(String[] args) {
        MyQueue queue = new MyQueue(4);
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);

        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());

        queue.enqueue(4);
        queue.enqueue(5);
        queue.enqueue(6);
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
    }
}
```

#### 基于数组实现
```java
public class MyQueue {

    // 队列中的数组
    private int[] data;

    // 头指针
    private int head;

    //尾指针
    private int tail;

    // 队列容量
    private int capacity;

    private int size;

    public MyQueue(Integer capacity) {
        data = new int[capacity];
        head = 0;
        tail = 0;
        size = 0;
        this.capacity = capacity;
    }

    public void enqueue(Integer value) {

        if(size >= capacity) {
            throw new IllegalStateException("Queue is full");
        }

        // 将元素放入数组的尾部
        data[tail] = value;
        // 尾指针后移
        tail = (tail + 1) % capacity;
        size ++;
    }

    public Integer dequeue() {
        if(size <= 0) {
            throw new IllegalStateException("Queue is empty");
        }

        // 获取队列头的元素
        int value = data[head];
        // 头指针后移
        head = (head + 1) % capacity;
        size --;
        return value;
    }

    public static void main(String[] args) {
        MyQueue queue = new MyQueue(4);
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);

        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());

        queue.enqueue(4);
        queue.enqueue(5);
        queue.enqueue(6);
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
    }
}
```




