---
layout: post
title: MD5加密及验证
date: 2018-03-16
categories: 加密算法
tags: [encrypt]
description: Java实现MD加密及验证过程。
---

**常见的几种加密方式**
1. 3DES,AES对称加密算法，是可逆的，使用这种方式加密可以通过获取秘钥解密来还原出原始密码
2. MD5,SHA1单向的加密算法，是不可逆的，无法通过计算还原出原始的密码
3. Base64编码：常用于邮件，http，加密，经常发现登录操作的用户名和密码是通过Base64加密的

**MD5随机盐值加密与验证（加密后为16进制字符串）**
```$xslt
package md5.util;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
/**
 * 使用Md5随机盐值加密及验证,不能直接拿请求的数据加密后与数据库中的数据验证，因为盐值是个随机数
 * @author zhoujianbo
 * @date 2017-06-06 10:36
 */
public class MD5EcoderUtil {

    private static final Integer SALT_LENGTH = 12;
    
    /**
     * 获取加密后的16进制形式字符串
     * @param str
     * @return String
     */
    public static String getEncrpytedStr(String str) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        SecureRandom random = new SecureRandom();
        //声明盐字节数组
        byte[] saltArray = new byte[SALT_LENGTH];
        //为saltArray数组随机生成元素
        random.nextBytes(saltArray);
        //为应用程序提供信息摘要算法，如 MD5 或 SHA 算法，信息摘要是安全的单向哈希函数
        MessageDigest md = MessageDigest.getInstance("MD5");
        //将盐数据传入信息摘要
        md.update(saltArray);
        //将要加密的字符串传入信息摘要对象中
        md.update(str.getBytes("UTF-8"));
        byte[] digest = md.digest();
        //盐字节数组和要加密的字符对应字节数组进行组合加密，得到encrpy_str
        byte[] strBytes = new byte[digest.length + SALT_LENGTH];
        //将盐的字节拷贝到最终加密口令字节数组的前12个字节，以便在验证口令时取出盐
        System.arraycopy(saltArray, 0, strBytes, 0, SALT_LENGTH);
        //将盐和字符串对应字节数组组合加密后的口令拷贝到最终加密口令字节数组内，从13个字节开始
        System.arraycopy(digest, 0, strBytes, SALT_LENGTH, digest.length);
        return  byteArrayToHexString(strBytes);
    }
    
    /**
     * 将验证未加密和加密后的字符串（盐值随机，不能直接拿请求的数据加密后与数据库中数据验证）
     * @param str
     * @param strEncrpyInDb
     * @return boolean
     */
    public static boolean  validate(String str, String strEncrpyInDb) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        //将加密后的字符串转换成字节数组
        byte[] encrpyInDbBytes = hexStringToByteArray(strEncrpyInDb);
        //定义盐字节数组
        byte[] saltBytes = new byte[SALT_LENGTH];
        //从加密后的字节数组中获取盐字节数组
        System.arraycopy(encrpyInDbBytes, 0, saltBytes, 0, SALT_LENGTH);
        //实例化消息摘要
        MessageDigest md = MessageDigest.getInstance("MD5");
        //将盐字节数组存入消息摘要中
        md.update(saltBytes);
        //将未加密的字符串对应字节数组存入消息摘要，和盐字节数组组合加密
        md.update(str.getBytes("UTF-8"));
        //获取请求数据的字节数组
        byte[] digest = md.digest();
        //定义DB中的除盐字节数组，即将最终加密后的字节数组前12位拿掉
        byte[] digestInDb = new byte[encrpyInDbBytes.length - SALT_LENGTH];
        //获取DB中的除盐字节数组，
        System.arraycopy(encrpyInDbBytes, SALT_LENGTH, digestInDb, 0, digestInDb.length);
        if (Arrays.equals(digest, digestInDb)) {
            return true;
        } else {
            return false;
        }
    }
    
    /**
     * 16进制表示的字符串转换成字节数组
     * @param hexString
     * @return byte[]
     */
    private static byte[] hexStringToByteArray(String hexString) {
        Integer hexStringLen = hexString.length();
        byte[] bytes = new byte[hexStringLen / 2];
        for(int i = 0 ; i < hexStringLen; i += 2) {
            /**
             * 两位一组，表示一个字节,把这样表示的16进制字符串还原成一个字节
             * Character.digit('A', 16) = 10，表示取16进制A的基数
             * 10 << 4 = 10 * 2^4 = 160，左移4位
             */
            bytes[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
        }
        return bytes;
    }
    
    /**
     * 字节数组转换成16进制字符串
     * @param bytes
     * @return String
     */
    private static String byteArrayToHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < bytes.length; i++) {
            String hexString = Integer.toHexString(0xFF & bytes[i]);
            if (hexString.length() == 1) {
                sb.append('0');
            }
            sb.append(hexString);
        }
        return sb.toString();
    }
}
```

**Base64编码与解码**
```$xslt
package md5.util;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
/**
 * 使用Md5随机盐值加密及验证,不能直接拿请求的数据加密后与数据库中的数据验证，因为盐值是个随机数
 * @author zhoujianbo
 * @date 2017-06-06 10:36
 */
public class MD5EcoderUtil {
    private static final Integer SALT_LENGTH = 12;
    /**
     * 获取加密后的16进制形式字符串
     * @param str
     * @return String
     */
    public static String getEncrpytedStr(String str) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        SecureRandom random = new SecureRandom();
        //声明盐字节数组
        byte[] saltArray = new byte[SALT_LENGTH];
        //为saltArray数组随机生成元素
        random.nextBytes(saltArray);
        //为应用程序提供信息摘要算法，如 MD5 或 SHA 算法，信息摘要是安全的单向哈希函数
        MessageDigest md = MessageDigest.getInstance("MD5");
        //将盐数据传入信息摘要
        md.update(saltArray);
        //将要加密的字符串传入信息摘要对象中
        md.update(str.getBytes("UTF-8"));
        byte[] digest = md.digest();
        //盐字节数组和要加密的字符对应字节数组进行组合加密，得到encrpy_str
        byte[] strBytes = new byte[digest.length + SALT_LENGTH];
        //将盐的字节拷贝到最终加密口令字节数组的前12个字节，以便在验证口令时取出盐
        System.arraycopy(saltArray, 0, strBytes, 0, SALT_LENGTH);
        //将盐和字符串对应字节数组组合加密后的口令拷贝到最终加密口令字节数组内，从13个字节开始
        System.arraycopy(digest, 0, strBytes, SALT_LENGTH, digest.length);
        return  byteArrayToHexString(strBytes);
    }
    /**
     * 将验证未加密和加密后的字符串（盐值随机，不能直接拿请求的数据加密后与数据库中数据验证）
     * @param str
     * @param strEncrpyInDb
     * @return boolean
     */
    public static boolean  validate(String str, String strEncrpyInDb) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        //将加密后的字符串转换成字节数组
        byte[] encrpyInDbBytes = hexStringToByteArray(strEncrpyInDb);
        //定义盐字节数组
        byte[] saltBytes = new byte[SALT_LENGTH];
        //从加密后的字节数组中获取盐字节数组
        System.arraycopy(encrpyInDbBytes, 0, saltBytes, 0, SALT_LENGTH);
        //实例化消息摘要
        MessageDigest md = MessageDigest.getInstance("MD5");
        //将盐字节数组存入消息摘要中
        md.update(saltBytes);
        //将未加密的字符串对应字节数组存入消息摘要，和盐字节数组组合加密
        md.update(str.getBytes("UTF-8"));
        //获取请求数据的字节数组
        byte[] digest = md.digest();
        //定义DB中的除盐字节数组，即将最终加密后的字节数组前12位拿掉
        byte[] digestInDb = new byte[encrpyInDbBytes.length - SALT_LENGTH];
        //获取DB中的除盐字节数组，
        System.arraycopy(encrpyInDbBytes, SALT_LENGTH, digestInDb, 0, digestInDb.length);
        if (Arrays.equals(digest, digestInDb)) {
            return true;
        } else {
            return false;
        }
    }
    /**
     * 16进制表示的字符串转换成字节数组
     * @param hexString
     * @return byte[]
     */
    private static byte[] hexStringToByteArray(String hexString) {
        Integer hexStringLen = hexString.length();
        byte[] bytes = new byte[hexStringLen / 2];
        for(int i = 0 ; i < hexStringLen; i += 2) {
            /**
             * 两位一组，表示一个字节,把这样表示的16进制字符串还原成一个字节
             * Character.digit('A', 16) = 10，表示取16进制A的基数
             * 10 << 4 = 10 * 2^4 = 160，左移4位
             */
            bytes[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i + 1), 16));
        }
        return bytes;
    }
    
    /**
     * 字节数组转换成16进制字符串
     * @param bytes
     * @return String
     */
    private static String byteArrayToHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < bytes.length; i++) {
            String hexString = Integer.toHexString(0xFF & bytes[i]);
            if (hexString.length() == 1) {
                sb.append('0');
            }
            sb.append(hexString);
        }
        return sb.toString();
    }
}
```