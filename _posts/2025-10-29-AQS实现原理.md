---
layout: post
title: AQS实现原理
date: 2025-10-14
tags: [concurrency]
---

#### 使用AQS实现锁
```java
public class MyLock {

    private AtomicBoolean flag = new AtomicBoolean(false);

    // 当前获取到锁的线程
    private Thread lockedThread;

    // 头结点为dummy结点
    private AtomicReference<Node> head = new AtomicReference<>(new Node());
    // 尾结点
    private AtomicReference<Node> tail = new AtomicReference<>(head.get());


    public void lock() {

        while(true) {

            // 1. 线程通过CAS操作获取到锁
            if(flag.compareAndSet(false, true)) {
                System.out.println(Thread.currentThread().getName() + " 获取到锁");
                lockedThread = Thread.currentThread();
                return;
            }

            // 2. 线程没有获取到锁，先放入双向链表的尾结点
            Node currentNode = new Node();
            currentNode.thread = Thread.currentThread();
            while (true) {
                Node currentTail = tail.get();
                if(tail.compareAndSet(currentTail, currentNode)) {
                    System.out.println(Thread.currentThread().getName() + " 放入链表尾部");
                    currentNode.prev = currentTail;
                    currentTail.next = currentNode;
                    break;
                }
            }

            while(true) {

                // 3. 放入链表之后，当前线程阻塞
                LockSupport.park();

                // 4. 当前线程被其他线程唤醒（只有头结点的下一个结点能被唤醒），并获取到锁之后，把当前结点作为头结点
                if(head.get().next == currentNode && flag.compareAndSet(false, true)) {
                    lockedThread = Thread.currentThread();
                    System.out.println(lockedThread.getName() + " 被唤醒并获取到锁");
                    head.set(currentNode);
                    currentNode.prev.next = null;
                    currentNode.prev = null;
                    return;
                }
            }
        }
    }

    public void unlock() {

        if(lockedThread != Thread.currentThread()) {
            throw new IllegalStateException("当前线程没有获取到锁，无法释放锁");
        }

        flag.set(false);

        // 释放头结点的下一个结点
        Node next = head.get().next;
        if(next != null) {
            LockSupport.unpark(next.thread);
        }
    }

    // 双向链表结点：前驱结点、后继结点、结点绑定的线程
    class Node {
        Node prev;
        Node next;
        Thread thread;
    }
}
```

#### 测试
```java
public class Test {

    public static void main(String args[]) throws InterruptedException {

        int[] arr = new int[]{100};

        List<Thread> threads = new ArrayList<>();

        MyLock lock = new MyLock();

        for (int i = 0; i < 100; i++) {
            Thread t = new Thread(() -> {
                lock.lock();
                arr[0] --;
                lock.unlock();
            }, String.valueOf(i));

            threads.add(t);
        }

        threads.forEach(Thread::start);

        for (Thread t : threads) {
            t.join();
        }
        
        System.out.println(arr[0]);
    }
}
```






