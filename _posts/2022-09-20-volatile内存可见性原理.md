---
layout: post
title: volatile内存可见性原理
date: 2022-09-20
tags: [并发编程]
---

#### 什么是内存可见性
在多线程访问同一共享变量时，某一线程对共享变量修改，其他线程能够能立即感知到修改后的值

#### Java内存模型(JMM)中的主内存与工作内存
所有的共享变量都存储在主内存中，每个线程有自己的工作内存，或称之为高速缓存。
线程内的工作内存拷贝了主内存变量的副本，线程对变量的操作都在工作内存中进行。线程读取变量时
先从工作内存中获取，工作内存没有时再从主内存读取并拷贝到工作内存中，同时线程修改变量时，先修改
本地内存，然后再刷新到主内存中

#### 内存模型图
![内存模型图](/images/volatile-memory.png)

#### 内存可见性问题
```java
public class Test {

    private static boolean flag = false;

    //private static volatile boolean flag = false;

    public static void main(String[] args) throws InterruptedException {

        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                while (!flag) {
                    //Thread.sleep(100);System.out.println("");
                }
                System.out.println("Thread1 run complete");
            }
        });

        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                flag = true;
            }
        });

        t1.start();
        //保证Thread1先执行
        Thread.sleep(3000);
        t2.start();
    }
}
```
上述代码运行会陷入while死循环，其执行过程如下：
1. Thread1先将主内存的共享变量拷贝到其工作内存中，然后获取工作内存中的变量副本
2. Thread1获取到flag变量值为false， 持续循环判断
3. Thread2先将主内存的共享变量拷贝到其工作内存中，然后获取工作内存中的变量副本
4. Thread2更新变量值为true，先更新工作内存，然后将更新后的变量更新到主内存中，Thread2结束
5. Thread1不知道共享变量被Thread2修改，仍然从工作内存中读取变量，结果仍为false，陷入死循环

- 若将while中Thread.sleep(100);或System.out.println("");注释去掉，Thread1的工作内存将会
刷新到主内存中更新后的值，从而变成跳出死循环。原因这俩语句都能造成线程阻塞，println方法内部使用了synchronized,
此时让cpu有空闲的时间按照JVM的要求去尽力保证内存的可见性，换句话说，只要cpu有时间，JVM会尽量去保证变量值的更新

- 若共享变量被volatile关键字修饰后，Thread2在更新flag值后，立即更新其工作内存及主内存，同时JVM会通知其他线程Thread1将工作
内存的变量副本置为失效，重新从主内存中拷贝最新的共享变量，此时可以保证内存的可见性

#### volatile如何保证内存可见性
1. 线程更新变量时立即刷新到主内存中（从工作内存刷新到主内存）
2. JVM通知其他线程将它们的工作内存中的变量副本置为失效，从新从主内存中拷贝

