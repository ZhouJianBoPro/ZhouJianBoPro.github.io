---
layout: post
title: 数据库与缓存一致性
date: 2024-09-03
tags: [other]
---

### 一致性
> 实际上数据库与缓存很难实现强一致性，因为数据库与缓存的写操作不是原子性的。在并发访问时有概率出现数据不一致的情况，
> 我们要做的是尽可能保证双方最终一致性，即允许数据在一段时间内不一致，但是在一定时间后，所有节点上的数据都一致

### 先更新数据库再更新缓存
1. 用户A更新数据库为1
2. 用户B更新数据库为2
3. 用户B更新缓存为2
4. 用户A更新缓存为1

> 在并发写操作时会造成数据库更新为2，缓存更新为1

### 先更新缓存后更新数据库
1. 用户A更新缓存为1
2. 用户B更新缓存为2
3. 用户B更新数据库为2
4. 用户A更新数据库为1

在并发写操作时会造成缓存为2，但是数据库为1

### 先删除缓存后更新数据库
1. 用户A删除缓存
2. 用户B获取缓存为空，然后读取数据库（旧值），并写入到缓存中
3. 用户A更新数据库（新值）

问题根源在于**读比写快**，在并发（写+读）时可能造成数据不一致。缓存的还是旧值，数据库已经更新为新值

### 先更新数据库后删除缓存
1. 用户A查询缓存为空，读取数据库（旧值）
2. 用户B更新数据库（新值），删除缓存
3. 用户A更新缓存

问题根源在于**读比写慢**，在并发（读+写）时可能造成数据不一致。缓存的还是旧值， 数据库已经更新为新值

### 方案选择
推荐使用先更新数据库后删除缓存方案，原因如下：
1. 缓存的写入效率远远大于数据库，出现数据不一致的概率相较于其他方案较低
2. 能保证数据库中的值始终是最新的

### 如何保证两者都操作成功
> 两者操作不推荐在同一线程中，一方面加大了业务接口的复杂度，同时对接口性能产生影响。
> 这样可能会存在数据库更新成功，但是缓存删除失败的情况。解决方案：
- 重试机制：缓存删除失败时加入到消息队列进行多次重试
- 订阅数据库binlog：可以使用canal订阅binlog，然后再操作缓存
- 设置缓存过期时间，保证数据最终一致性