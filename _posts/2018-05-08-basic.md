---
layout: post
title: basic
date: 2018-05-08
categories: basic
tags: [basic]
description: java语言基础积累
---

**static关键字**<br/>
1.每个对象共有的属性可以设置为static，静态变量被所有对象共享<br/>
2.成员变量和静态变量的区别：
- 两个变量的生命周期不同：1）成员变量随着对象的创建而存在，随着对象的回收而释放；2）静态变量随着类的加载而加载，优先于对象的创建
- 调用方式不同：1）成员变量只能通过对象调用；2）静态变量可以通过类名调用
- 数据存储方式不一样：1）成员变量存储在堆内存中；2）静态变量存储在方法区中，也成共享区

3.静态方法<br/>
- 只能访问静态成员（非静态方法即可以访问静态和非静态成员）
- 静态方法中不能使用this，super关键字（对象不存在）
- 静态方法使用场景：不需要访问非静态变量一般定义为静态方法

4.使用静态方法和静态变量的好处：不必实例化对象就可以通过类名调用，降低了对象创建和销毁耗费的资源

**java内存**

1.栈内存
> 栈内存中存放一些基本类型的变量或对象的引用变量，当超过该变量的作用域后，java会自动释放为该变量分配的内存的空间

什么是对象的引用？
```html
Demo demo = new Demo();
此时new Demo()创建一个对象，该对象存储在堆内存中，然后该对象被demo引用，此时称之为对象的引用
```

2.堆内存
> 堆内存用于存放由new创建的对象和数组，堆内存分配的内存，由java虚拟机垃圾回收机制自动回收

栈中的变量指向堆内存中的变量，数组和对象在没有引用变量引用时才变成垃圾，不能被再次使用，
但是不会立即被释放，在随后的一个不确定的时间内被java虚拟机垃圾回收机制被回收

**Map相关**

1.hashMap是如何进行扩容的？<br/>
> hashMap在每次put时都判断length长度，如果length长度超出最大限制，则调用扩容方法进行扩容

2.HashMap、HashTable、ConcurrentHashMap之间的区别?<br/>
- hashMap键值可以为null,HashTable、ConcurrentHashMap键值为null时会抛出异常
- HashMap非线程安全，HashTable、ConcurrentHashMap线程安全
- 因为线程安全、哈希效率，HashMap执行效率最高

3.HashTable、ConcurrentHashMap在高并发场景下哪个效率较高？
- HashTable是多个线程竞争同一把锁，会造成其他线程堵塞，put，get, remove方法都是同步的
- ConcurrentHashMap：使用分段锁，相当于将一个HashMap进行分割，然后对每部分分配一把锁，这样就可以支持多线程进行访问了

**java中四种修饰符**
> public > protected > defalut > private

**final关键字**
1.final关键字可以修饰变量方法及类
2. 通过final关键字修饰的变量是个常亮，不能重新赋值
3. 通过final关键字修饰的方法不能被子类重写
4. 通过final修饰的类不能被继承，并且该类中的方法全部都为final

**接口和抽象类的区别**
1. 接口和抽象类都不能创建对象，可以指向子类或实现类的对象
2. 接口中定义的方法都是抽象方法，实现类中都要有具体的实现；抽象类中可以定义非抽象方法，抽象方法需要在子类中有具体的实现
3. 接口能够多实现，抽象类只能单继承
4. 方法上，抽象类可以被public/protected [abstract]修饰，接口默认修饰符为public abstarct
5. 抽象类可以含有构造方法，接口不能含有构造方法
6. 抽象类中可以有静态方法和静态代码块，接口中不能含有静态方法及代码块

**传值和传引用的区别**
- 在方法调用时，将实际参数的副本传递给形参，两者的基本类型一致
- 方法调用时，实际参数的引用被传递给形式参数，函数接收到的是原始值的内存地址，实参和形参执行同一块内存地址

**char类型转换**
- char类型能够隐式转换成int,doubble
- char类型要显式转换成byte,short
- char类型不能转换成string

**JDK8新特性之Optional**
- Optional，Optional.ofNullable(T value)中设置的参数可以为null，ispresent()方法判断诗句是否为空

**JDK8新特性之Lambda表达式及Stream api**

1.列表迭代
```java
list.forEach(x -> System.out.println(x));
```
2.过滤列表中的元素
```java
list.stream().filter(x -> x >= 2).collect(Collectors.toList());
```
3.map将一个列表映射成另一个
```java
list.stream().map(x -> ++x).collect(Collectors.toList());
```
4.reduce将列表中的值合并成一个
```java
list.stream().reduce((y, x) -> y * x).get();
```
5.对集合中的元素去重
```java
list.stream().distinct().collect(Collectors.toList());
```
6.排序
```java
list.stream().sorted((o1, o2) -> o2 - o1).collect(Collectors.toList());
```

**Integer和int之间的比较**

- int和Integer(无论new否)之间的比较时使用 == Integer会进行拆箱处理，返回true
- 两个new Integer比较时，都为false, 两个对象的内存地址不一样
- Integer和new Integer 比较时，返回false, Integer指针指向常量池，new Integer指向堆
- 两个非new Integer比较时，如果值在-128至127之内，返回true(在编译的时候处理成Integer.valueof(),使用到IntegerCache，将缓存的值取出，不用new Integer)；
如果值不在-128至127内时(会new对象出来)，返回false

**List集合中删除指定值**

1. 采用遍历的方式删除：<br/>
```java
for(Integer i; i < list.size(); i++) {
    if(list(i) == 2) {
        list.remove(i);
        i --;
       
    }
}
```

2. 使用removeAll()：<br/>
```java
List<Integer> removeList = Lists.newArrayList();
for(Integer i : list) {
    if(i == 2) {
        removeList.add(i)
    }
}
list.removeAll(removeList);
```

3. 使用Iterator迭代删除
```java
Iterator<Integer> it = list.iterator();
while(it.hasNext()) {
    if(it.next() == 2) {
        it.remove();
    }
}
```







