---
layout: post
title: basic
date: 2018-05-08
categories: basic
tags: [basic]
description: java语言基础积累
---

**static关键字**<br/>
1.每个对象共有的属性可以设置为static，静态变量被所有对象共享<br/>
2.成员变量和静态变量的区别：
- 两个变量的生命周期不同：1）成员变量随着对象的创建而存在，随着对象的回收而释放；2）静态变量随着类的加载而加载，优先于对象的创建
- 调用方式不同：1）成员变量只能通过对象调用；2）静态变量可以通过类名调用
- 数据存储方式不一样：1）成员变量存储在堆内存中；2）静态变量存储在方法区中，也成共享区

3.静态方法<br/>
- 只能访问静态成员（非静态方法即可以访问静态和非静态成员）
- 静态方法中不能使用this，super关键字（对象不存在）
- 静态方法使用场景：不需要访问非静态变量一般定义为静态方法

4.使用静态方法和静态变量的好处：不必实例化对象就可以通过类名调用，降低了对象创建和销毁耗费的资源

**java内存**

1.栈内存
> 栈内存中存放一些基本类型的变量或对象的引用变量，当超过该变量的作用域后，java会自动释放为该变量分配的内存的空间

什么是对象的引用？
```html
Demo demo = new Demo();
此时new Demo()创建一个对象，该对象存储在堆内存中，然后该对象被demo引用，此时称之为对象的引用
```

2.堆内存
> 堆内存用于存放由new创建的对象和数组，堆内存分配的内存，由java虚拟机垃圾回收机制自动回收

栈中的变量指向堆内存中的变量，数组和对象在没有引用变量引用时才变成垃圾，不能被再次使用，
但是不会立即被释放，在随后的一个不确定的时间内被java虚拟机垃圾回收机制被回收

**Map相关**

1.hashMap是如何进行扩容的？<br/>
> hashMap在每次put时都判断length长度，如果length长度超出最大限制，则调用扩容方法进行扩容

2.HashMap、HashTable、ConcurrentHashMap之间的区别?<br/>
- hashMap键值可以为null,HashTable、ConcurrentHashMap键值为null时会抛出异常
- HashMap非线程安全，HashTable、ConcurrentHashMap线程安全
- 因为线程安全、哈希效率，HashMap执行效率最高

3.HashTable、ConcurrentHashMap在高并发场景下哪个效率较高？
- HashTable是多个线程竞争同一把锁，会造成其他线程堵塞
- ConcurrentHashMap：使用分段锁，相当于将一个HashMap进行分割，然后对每部分分配一把锁，这样就可以支持多线程进行访问了

**java中四种修饰符**
> public > protected > defalut > private

**接口和抽象类的区别**
1. 接口和抽象类都不能创建对象，可以指向子类或实现类的对象
2. 接口中定义的方法都是抽象方法，实现类中都要有具体的实现；抽象类中可以定义非抽象方法，抽象方法需要在子类中有具体的实现
3. 接口能够多实现，抽象类只能单继承
4. 方法上，抽象类可以被public/protected [abstract]修饰，接口默认修饰符为public abstarct
5. 抽象类可以含有构造方法，接口不能含有构造方法
6. 抽象类中可以有静态方法和静态代码块，接口中不能含有静态方法及代码块

**传值和传引用的区别**
- 在方法调用时，将实际参数的副本传递给形参，两者的基本类型一致
- 方法调用时，实际参数的引用被传递给形式参数，函数接收到的是原始值的内存地址，实参和形参执行同一块内存地址

**一个arrayList在遍历时删除会不会出现问题**
- 会出现问题（被删除索引对应的值变成了下一个索引的值），就像吃蛋糕，从下往上看，如果吃掉之间一层，
上面几层都会变
- 解决办法：list.removeAll(delList)，逆序遍历并删除

**解决@Transactional事务不起效**
- 检查方法是不是public的
- 异常类型是不是unchecked异常，被catch了的异常事务是不起效的
- 数据库引擎要支持事务，如果是innerDB则支持

**springMVC工作流程**
![](/images/springMVC.png)

1. 用户发送请求至中央控制器(DisPatchServlet)，用于接收请求，分发请求，响应请求
2. DispatchServlet收到请求调用HandlerMapping处理器映射器（根据请求url查找处理器）
3. 返回处理器(Handler)至DispatchServlet
4. DispatchServlet通过HandlerAdapter处理器映射器调用处理器
5. 执行处理器（controller）（处理业务请求）
6. Controller执行完返回ModelAndView至DispatchServlet
7. DispatchServlet将ModelAndView传递给视图解析器（ViewReslover）
8. 视图解析器解析后返回View至DispatchServlet
9. DispatchServlet对View进行渲染(向view中填充数据)
10. DispatchServlet对用户请求进行相应

**spring管理事务的方式**
- 编程式事物（硬编码实现，不推荐）
- 声明式事物（1.基于xml配置声明式事物；2.基于注解声明式对象）

**什么是显示转换和隐式转换**
- 显式转换：将大类型强转成小类型n
- 隐式转换：大范围变量能够接受小范围对象的变量

**char类型转换**
- char类型能够隐式转换成int,doubble
- char类型要byte,short
- char类型不能转换成string

**try catch执行顺序**
当try中有return语句时，finally语句会先于try中return执行

**JDK8新特性之Optional**
- Optional，Optional.ofNullable(T value)中设置的参数可以为null，ispresent()方法判断诗句是否为空

**JDK8新特性之Lambda表达式及Stream api**

1.列表迭代
```java
list.forEach(x -> System.out.println(x));
```
2.过滤列表中的元素
```java
list.stream().filter(x -> x >= 2).collect(Collectors.toList());
```
3.map将一个列表映射成另一个
```java
list.stream().map(x -> ++x).collect(Collectors.toList());
```
4.reduce将列表中的值合并成一个
```java
list.stream().reduce((y, x) -> y * x).get();
```
5.对集合中的元素去重
```java
list.stream().distinct().collect(Collectors.toList());
```
6.排序
```java
list.stream().sorted((o1, o2) -> o2 - o1).collect(Collectors.toList());
```






